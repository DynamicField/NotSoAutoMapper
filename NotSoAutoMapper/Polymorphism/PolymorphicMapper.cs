using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using NotSoAutoMapper.ExpressionProcessing;
using LinqExpression = System.Linq.Expressions.Expression;

namespace NotSoAutoMapper.Polymorphism
{
    /// <summary>
    /// <para>
    /// Maps the object inheritance tree of <typeparamref name="TBaseInput"/> by mapping its subtypes. This
    /// type can be constructed using <see cref="PolymorphicMapperBuilder{TBaseInput,TBaseResult}"/>.
    /// </para>
    /// <para>
    /// This type works well in combination with the
    /// <see cref="MergingExtensions.Merge{TBaseInput,TInput,TBaseResult,TResult}(System.Linq.Expressions.Expression{System.Func{TBaseInput,TBaseResult}},System.Linq.Expressions.Expression{System.Func{TInput,TResult}})">
    /// Merge</see> extension method, which allows reusing the common mapping properties for your subtypes.
    /// A usage example can be found in <see cref="PolymorphicMapperBuilder{TBaseInput,TBaseResult}"/>. 
    /// </para>
    /// </summary>
    /// <remarks>
    /// <para>
    /// Unlike <see cref="Mapper{TInput,TResult}"/>, this mapper computes its <see cref="Expression"/> lazily.
    /// This behavior avoids issues with static initialization.
    /// </para>
    /// <para>
    /// The expression generated by this mapper is a chain of ternary expressions, using the following pattern:
    /// <code>
    /// x is [Mapping.InputType] ?
    /// ([TResult]) [Mapping.MapperExpression { ([Mapping1.InputType]) x }]
    /// : [Next Mapping OR default]
    /// </code>
    /// For example, let's assume we have three types with three mappings: Base, Derived1 and Derived2.
    /// Like their names suggest, Derived1 and Derived2 inherit from Base. They all have DTO types.<br/>
    /// The resulting expression will have the following body:
    /// <code>
    /// x => x is Derived1 ? (BaseDto) new Derived1Dto {
    ///     SharedProperty = ((Derived1) x).SharedProperty,
    ///     Derived1Property = ((Derived1) x).Derived1Property,
    /// } : x is Derived2 ? (BaseDto) new Derived2Dto {
    ///     SharedProperty = ((Derived2) x).SharedProperty,
    ///     Derived2Property = ((Derived2) x).Derived2Property,
    /// } : x is Base ? (BaseDto) new BaseDto {
    ///     SharedProperty = ((Base) x).SharedProperty
    /// } : null
    /// </code>
    /// The most derived types are always prioritized first to avoid mismatches. If the Base mapping was
    /// the first in the ternary chain, the other Derived1/2 mappings would've been ignored!
    /// </para>
    /// </remarks>
    /// <typeparam name="TBaseInput">The base input type.</typeparam>
    /// <typeparam name="TBaseResult">The base result type.</typeparam>
    /// <seealso cref="PolymorphicMapperBuilder{TBaseInput,TBaseResult}"/>
    /// <seealso cref="MergingExtensions.Merge{TBaseInput,TInput,TBaseResult,TResult}(System.Linq.Expressions.Expression{System.Func{TBaseInput,TBaseResult}},System.Linq.Expressions.Expression{System.Func{TInput,TResult}})"/>
    public sealed class PolymorphicMapper<TBaseInput, TBaseResult> : AbstractMapper<TBaseInput, TBaseResult>
        where TBaseInput : notnull
        where TBaseResult : notnull
    {
        private readonly PolymorphicMapping<TBaseInput, TBaseResult> _mapping;
        private readonly Lazy<Expression<Func<TBaseInput, TBaseResult>>> _lazyExpression;

        /// <summary>
        /// Creates a new <see cref="PolymorphicMapper{TBaseInput,TResult}"/> using the given
        /// mapping, describing how to map the inheritance tree.
        /// </summary>
        /// <param name="mapping">The polymorphic mapping, describing how to map the inheritance tree.</param>
        public PolymorphicMapper(PolymorphicMapping<TBaseInput, TBaseResult> mapping)
        {
            _mapping = mapping;
            _lazyExpression = new(CreatePolymorphicExpression);
        }

        private Expression<Func<TBaseInput, TBaseResult>> CreatePolymorphicExpression()
        {
            // Objective:
            // x is [Mapping.InputType] ?
            // ([TResult]) [Mapping.MapperExpression { ([Mapping1.InputType]) x }]
            // : [Next Mapping OR default]

            var inputParameter = LinqExpression.Parameter(typeof(TBaseInput), "x");

            var conditionalUnits = new List<(LinqExpression condition, LinqExpression expression)>();
            foreach (var entry in _mapping.Entries)
            {
                var mappingExpression = entry.ExpressionGetter();

                // (<Mapping.InputType>) x
                var castedParameter = LinqExpression.ConvertChecked(inputParameter, entry.InputType);
                // x is <Mapping.InputType>
                var condition = LinqExpression.TypeIs(inputParameter, entry.InputType);
                // Mapper((<Mapping.InputType>) x)
                var expression = MapperInliningOperations.InlineMapperExpression(mappingExpression, castedParameter,
                    false);

                // This cast is needed to make the ternary work.
                // (TResult) Mapper((<Mapping.InputType>) x)
                expression = LinqExpression.ConvertChecked(expression, typeof(TBaseResult));

                conditionalUnits.Add((condition, expression));
            }

            // Traverse the units in reverse, we stack up the expressions as we go.
            LinqExpression? finalExpression = null;
            for (var i = conditionalUnits.Count - 1; i >= 0; i--)
            {
                var (condition, expression) = conditionalUnits[i];

                finalExpression = LinqExpression.Condition(condition,
                    expression,
                    finalExpression ?? MakeDefaultExpression.For(typeof(TBaseResult)));
            }

            return LinqExpression.Lambda<Func<TBaseInput, TBaseResult>>(finalExpression!, inputParameter);
        }

        /// <inheritdoc />
        public override Expression<Func<TBaseInput, TBaseResult>> Expression => _lazyExpression.Value;
    }
}